STDIN / STDOUT
Всё, что вы пишите в окне и подтверждаете (с помощью ENTER), называется стандартным вводом (STDIN).
Всё, что программа выводит в ответе в терминал (например текст из файла), называется стандартным выводом (STDOUT)Конвейер (piping)
	1. | 

Pipe принимает STDOUT от команды слева от pipe и превращает его в STDIN для команды справа от pipe.
пример: echo 'test text' | wc -l
	1. >

Символ "больше" принимает STDOUT от команды слева и записывает/перезаписывает в новый файл справа
пример:  ls > tmp.txt
	1. >>

Два символа "больше" принимают STDOUT от команды слева и добавляют к новому или существующему файлу справа.
пример: date >> tmp.txtШаблоны поиска (wildcards)
Можете представить это как символ % в SQL. Например, можно написать WHERE first_name LIKE 'John%', чтобы найти любые позиции, где данные начинаются с имени John.
В bash можно написать John*. Если вы хотите вывести список всех файлов в какой-то папке, заканчивающихся на ".json", пишете : ls *.jsonЗавершение с помощью tab
Bash часто завершает команды сам, по определённой логике, если вы начинаете вводить команду и нажимаете TAB.
Однако, стоит попробовать что-то вроде zsh или fish для автозаполнения, потому что запоминать команды и все их параметры очень сложно. Более того, эти инструменты применят автозаполнение, основываясь на вашей истории используемых команд.Выход
Иногда вы застреваете в какой-нибудь программе и не можете оттуда выйти. Это очень часто повторяющееся событие для новичков в Linux, которое невероятно демотивирует. Часто выход происходит с помощью чего-то, содержащего q. Хорошо бы запомнить то, что будет написано ниже и использовать, когда вы в ловушке.

	* Bash
	* CTRL+c
	* q
	* exit
	* Python: quit()
	* Nano: CTRL+x
	* Vim: <Esc> :q!

Что я помню из команд bash
Это те команды, которые я использую чаще всего в Linux (начиная от самых часто используемых к самым редко используемым). Как я уже писал раньше, знание всего горстки команд поможет выполнять большой набор необходимых программируемых задач.

	*  cd {directory} изменить директорию
	*  ls -lha вывести директорию в виде списка (подробного)
	*  vim или nano редактор командной строки
	*  touch {file} создать новый пустой файл
	*  cp -R {original_name} {new_name} скопировать файл или директорию (и всё их содержимое)
	*  mv {original_name} {new_name} переместить или переименовать файл
	*  rm {file} удалить файл
	*  rm -rf {file/folder} удалить файл или папку без возможности восстановления [использовать аккуратно!]
	*  pwd вывести текущую рабочую директорию
	*  cat или less или tail или head -n10 {file} вывести в STDOUT содержимое файла
	*  mkdir {directory} создать пустую директорию
	*  grep -inr {string} найти строку в любом файле этой директории или дочерних директориях
	*  column -s, -t <delimited_file> отобразить разделенный запятыми файл в виде столбцов
	*  ssh {username}@{hostname} соединиться с удалённой машиной
	*  tree -LhaC 3 показать структуру директории на 3 уровнями вглубь (с размерами файлов и включая скрытые директории)
	*  htop (или top) диспетчер задач
	*  pip install --user {pip_package} пакетный менеджер Python для установки пакетов в ~/.local/bin
	*  pushd . ; popd ; dirs; cd - push/pop/view директорию в стек + изменить обратно на последнюю директорию
	*  sed -i "s/{find}/{replace}/g" {file} заменить строку в файле
	*  find . -type f -name '*.txt' -exec sed -i "s/{find}/{replace}/g" {} \; заменить строку для каждого файла в этой и дочерней папках с именем типа *.txt
	*  tmux new -s session, tmux attach -t session создать новую сессию терминала без создания нового окна [продвинутый уровень]
	*  wget {link} загрузить веб-страницу или веб-ресурс
	*  curl -X POST -d "{key: value}" http://www.google.com отправить HTTP-запрос на веб-сервер
	*  find <directory> вывести список всего содержимого директории и её дочерних директорий рекурсивно

Продвинутые и не часто используемые команды

	*  lsof -i :8080 вывести список дескрипторов открытых файлов (-i — флаг для сетевых интерфейсов)
	*  netstat | head -n20 вывести список открытых интернет/UNIX сокетов и связанной с ними информации
	*  dstat -a транслировать текущий диск, сеть, активность CPU и другое
	*  nslookup <IP address> найти hostname для удалённого IP-адреса
	*  strace -f -e <syscall> <cmd> отследить системные вызовы программы (-e — флаг для фильтрования конкретных системных вызовов)
	*  ps aux | head -n20 вывести текущие активные процессы
	*  file <file> проверить тип файла (например исполняемый, бинарный, текстовый файл с кодировкой ASCII)
	*  uname -a информация о ядре ОС
	*  lsb_release -a информация об ОС
	*  hostname проверить hostname текущего компьютера (например, название, чтобы другие компьютеры могли иметь доступ к вашему)
	*  pstree визуализировать форки процессов
	*  time <cmd> исполнить команду и составить статистику о том, сколько времени потребовалось на исполнение
	*  CTRL + z ; bg; jobs; fg отправить процесс в текущий tty в background и обратно на передний план
	*  cat file.txt | xargs -n1 | sort | uniq -c посчитать количество уникальных слов в файле
	*  wc -l <file> количество строк в файле
	*  du -ha показать размер на диске для директорий и их содержимого
	*  zcat <file.gz> вывести содержимое заархивированного текстового файла
	*  scp <user@remote_host> <local_path> скопировать файл с удалённого на локальный сервер или наоборот
	*  man {command} показать инструкцию, (т.е. документацию) для команды (но скорее всего легче использовать Google)