Внимание, испытание повышенной сложности!

### Аннотации функций

В Python с версии 3.0 существует синтаксис, позволяющий дополнить описание аргумента функции аннотацией. Выглядит это так:

```
def multiply(times: int, value: str) -> str:
    return value * times
```

Здесь через : указаны аннотации для аргументов, а -> указывает тип возвращаемого значения. Аннотацией может быть любое Python-выражение. Сам Python вычисляет значения выражений в момент выполнения блока кода, в котором объявлена функция (в этот момент выполнится print в примере ниже) и сохраняет аннотации в атрибуте __annotations__ объекта функции.

В дальнейшем сам интерпретатор никак эти значения не использует, но их может использовать программист! Вот как выглядят аннотации с точки зрения интерпретатора:

```
def f(
    x: 1 + 2,
    y: print("Hello!"),
    z: "this is zet!",
    foo: {'a': 42, 'b': 'bar'}
):
    pass

Hello!
f.__annotations__
# {'x': 3, 'y': None, 'z': 'this is zet!', 'foo': {'a': 42, 'b': 'bar'}}
```

Как видите, это просто словарь, где ключи — имена аргументов, а значения — результаты вычисления выражений-аннотаций!

Подробнее об аннотациях функций можно почитать в соответствующем "PEP 3107 - Function Annotations".


Вам предстоит написать пару декораторов, выполняющих проверку типов аргументов согласно их (аргументов) аннотациям. Если при вызове функции тип какого-либо значения не соответствует указанному в аннотации типу аргумента, обёрнутая функция не должна быть вызвана. Вместо этого декоратор должен вернуть соответствующую ошибку.

Требуемые для реализации функции уже объявлены в модуле, но не реализованы. docstrings функций описывают (в порядке исключения — на русском) принимаемые функциями аргументы. Можете считать эти "болванки" функций техническим заданием :)

### Уточняю несколько моментов:

- функция typecheck() останавливает выполнение (и проверку) на первой ошибке типизации;
- функция typecheck_all() проверяет все аргументы, накапливая ошибки, и лишь потом останавливает выполнение, если ошибки были;
- обе функции оборачивают только функции, принимающие именованные аргументы;
аннотации должны быть простыми типами, чтобы можно было проверить соответствие типа с помощью вызова isinstance(value, some_type).

Постарайтесь выразить typecheck_all() через typecheck(). Это непросто, но интересно!