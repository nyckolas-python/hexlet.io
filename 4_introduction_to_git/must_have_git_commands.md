# Начало работы в Git - установка на Ubuntiu
sudo apt-get update # на всякий случай смотрим новые версии
sudo apt install git-all # установка git на Linux
git --version # проверяем версию после установки
# конфигурация git cofig
git config --global user.name "<имя фамилия>" # после установки настрока конфигурации
git config --global user.email "your_email@example.com" # после установки настрока конфигурации
git config --local --list # просмотр локальной конфигурации
git config --global --list # просмотр глобальной (для всех пользователей) конфигурации
git config --global color.ui true # включение/выкл подсветки кода цветом
git config --global core.editor vi # изменить редактор по умолчанию
cat etc/gitconfig # вывод системной конфигурации, если есть
cat ~/.gitconfig # вывод локальной конфигурации
git config <поле.конфига> 'значение' # любое поле из git config --local --list можно изменить по этому шаблону

# Создание ssh-ключей
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
# Дальше будет несколько вопросов. На все вопросы нужно нажимать Enter.
# Запуск агента ssh, который следит за ключами (на Windows можно нет)
eval "$(ssh-agent -s)"
# Добавления нового ssh-ключа в агент (на Windows можно нет)
ssh-add ~/.ssh/id_rsa
# выводим ssh ключ на экран, копируем его и вставляем на github, попросят назвать его называем по логике HOME, WORK, NOTE
cat ~/.ssh/id_rsa.pub
# в той директории где желаем сделать репозиторий вводим команду инициализации
cd first-git # переход в желаемую директорию
git init # инициализация git
git status # показывает текущий статус

# Добавление в репозиторий происходит в два шага. git add и git commit -m 'коментарий одного конкретного изменения для файла' или .
git add <путь до файла> # добавляем для каждого нового или измененного файла или . для всех неотслеживаемых файлов в каталоге
git commit -m -a 'коментарий одного конкретного изменения для файла' # флаг -m Пропусти запуск редактор для уточнения коммента коммита, фл>
git commit --amend # добавляет изменения к последнему коммиту
git commit --fixup=<хеш_для_склейки> # позже при интерактивном rebase --autosqush можно будет автоматом склеять

# для того что бы наш репозиторий выгрузился онлайн необходимо на github.com создать новый репозит с таким же название директории где был >
# Github предложит следующие комманды, выполняем ИХ:
git branch -M main
git remote add origin git@github.com:<ИМЯ НА ГИТХАБЕ>/first-git.git # 'first-git' - это имя директирии на локальном
git push -u origin main
git push # пушит все закоммиченые изминения и выгружает их на github.com
git pull --rebase # забирает все изминения (добавления и коммиты) на локальную машину, их можно увидеть

#Репозиторий, созданный на Github, — публичный. Любой человек может клонировать его к себе на компьютер и начать работать с ним так, как б>
git clone git@github.com:<ИМЯ НА ГИТХАБЕ>/first-git.git # 'first-git' - это имя репозита/директории КЛОНИРУЕМ РЕПОЗИТ СЕБЕ
rm -rf <путь до файла> # рекурсивно удаляет НЕ пустую папку с файлами
git rm PEOPLE.md # равносильно rm PEOPLE.md + git add PEOPLE.md, останется только закомитить

# Выведет все изменения сделанные в рабочей директории
# сравнит изменения в файлах что было - что стало
git diff # флаг --staged для изменений которые были добавлены в индекс



git log # выводит список всех выполненных коммитов, отсортированных по дате добавления (сверху самые последние)
git log -p # Тут все коммиты с полным дифом. Мотать вперед f, мотать назад u. Выйти из режима просмотра — q
git show <хеш коммита> # выводит все изминения по хешу коммита
git show blame <путь до файла> # выводит рядом с каждой строчкой хеш коммита и кто менял её, дату правки
git grep <фраза_поиска> <хеш коммита> # поиск по фразе, возможен поиск по кон
кретному коммиту, есть разные флаги -i без учета регистра и т.д.

# ОТМЕНА ИЗМЕНЕНИЙ:
git checkout -- <имя_файла> # отменяет изменения в конкретном <имя_файла> не добавленном в идекс
git checkout -- . # отменяет изменения во всех файлах не добавленных в индекс
git clean -fd # адаляет все файлы которые не добавленные в индек -> not add. -f – force, -d – directory
git restore <путь к файлу/имя> # востанавливает измененный файл в рабочей директории, но еще не добавлен в индекс add
git restore --staged <путь к файлу/имя> # востанавливает файл измененный и УЖЕ добавлен в индек, но еще не закоммичен
git reset --soft HEAD~ # удаляет коммит, но изменения попадают в индекс для доработки
git reset --hard HEAD~ # удаляет полностью коммит флаг --hard = без следа. если без --hard то останется в рабочей области. флаг HEAD~ указ>
git revert <хеш_коммита> <хеш_коммита> # если нужно отменить одини или несколько коммитов, но оставить все текущие изменения. Часто исполь>
git revert <хеш_коммита>^..@<хеш_коммита> # если нужно отменить диапазон коммитов
git rebase --interactive c4d25d6^ - изменить коммент конкретного коммита. после чего меняем pick на reword:
pickreword c4d25d6 order status
pick 39ba64e redirect to order status after booking

# АНАЛИЗ ИЗМЕНЕНИЙ:
git switch -c <new-branch-name> # переключает в НОВУЮ <new-branch-name> используем флаг -c
git add -i # флаг -i запускает пейджер для подробного просмотра и выбора файлов для добавления в индекс
git add -p # выполнения частичной индексации файлов -- path


# СРОЧНАЯ ЗАДАЧА:
# Иногда появляется срочная задача — сделать какое-то изменение в исходном коде, не связанное с тем, над чем вы сейчас работаетеш. Для это>
git stash # добавляеет прячет все изменения незакоммиченые (добавленые и НЕ добавленные в индекс) в stash (заначку)
git stash pop # возвращает спрятанные изменения из stash в рабочую директорию
git stash list # выводит что есть в stash
git stash pop stash@{номер} # возвращает конкретный номер stash из заначки в рабочую директорию
git stash drop stash@{номер} # удаляет конкретный номер stash из заначки
git stash clear # удаляет всё из заначки

git checkout <e6f625c хеш коммита> # Переключимся на момент, когда был выполнен коммит с хеш e6f625c


# Одна ветка - одна задача с коммитами. Для начала выполнения задачи создаем новую ветку. Работаем в ней. После завершения делает git merg>
git branch -b <название ветки> # Содаем новую ветку и паремтром -b перееключаемся на неё
git branch --merged # Проверяем влитые ветки, после чего их иожно удадить.
git branch -d <название ветки> # Удаляем указаную ветку
git switch <название ветки> # переключает в <названую ветку>
git switch - # переключает в предыдущую активную ветку. в качестве парамера шорткат - дефис

# ЕСЛИ ЗАКОМИТЕЛ НЕ В ТУ ВЕТКУ:
git checkout <хеш_коммита_предыдущего> # возвращаемся на коммит назад
git checkout -b <имя_новой_ветки> # создаём новую ветку или git branch -b <название ветки>
git cherry-pick <хеш_коммита_нужного> # копируем нужный коммит в текущую ветку
git checkout main # переходим в ветку где был не верно закоммичен
git reset --hard HEAD^1 # удаляем последний коммит

# ПЕРЕМЕЩЕНИЕ ВЕТКИ, ИЗБАВЛЯЕМСЯ ОТ ПЕТЕЛЬ:
git rebase main # перед git merge обязательно делаем git rebese <ветка_для_мёржа>
git rebase --onto main branchA branchB # перемещает подветку branchB в хвост main, после можно мёржить (вливать)
# для выпрямления (моржа, влития ветки) merge, что бы не напутать лишних петель, особенно если есть вложения ветка
#               o---o---o---o---o  master
#                    \
#                     o---o---o---o---o  next
#                                      \
#                                       o---o---o  topic
git rebase --onto master next topic
#
#               o---o---o---o---o  master
#                   |                   \
#                   |                    o---o---o  topic
#                    \
#                     o---o---o---o---o  next
# МЕНЯЕМ ИСТОРИЮ, МААСОВОЕ ИЗМЕНЕНИЕ КОММИТОВ:
git rebase -i --autosquash <хеш_коммита> # меняем начиная коммиты с хеш_коммита до HEAD
# каждому коммиту можно изменить: удаление коммита, изменение коммит-сообщения, слияние коммитов и изменение состава коммита (коммит можно>
git rebase -i --autosquash HEAD~2 # меняем последних 3 коммита + автосклейка если есть fixup коммиты
# вызывает пейджер в котором предложит изменить кортеж коммитов начиная с <хеш_коммита> до HEAD
# ФОРСИРОВАННЫЙ git push:
git push origin <branch_name> --force # Если до этого пушили все коммиты на репу, то исппользуем форсированный пуш

# СОВМЕСНАЯ РАБОТА НАД ПРОЕКТОМ копируем/забираем/отдаем изменения:
git clone http://user@somehost:port/~user/repository/project.git # клонирует удаленный ребозиторий в рабочую директорию
git fetch /home/username/project # забирает изминения для определенной репки
git remote add username-project /home/username/project # добавляет синоним проекта 'username-project' вместо относительного /home/username>
git fetch username-project # забираем изменения по адресу определенному синонимом
git diff # Естественно, что после оценки изменений, например, командой git diff, надо создать коммит слияния с основной
git merge username-project/main # после оценки git diff надо создать коммит слияния с основной веткой
git pull username-project --tags # git pull = git fetch + git merge
# то есть git pull сразу забирает изминения из репки и проводит слияние с активной веткой